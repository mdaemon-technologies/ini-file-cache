import*as t from"fs";import*as e from"path";import i from"@mdaemon/emitter/dist/emitter.cjs";function s(i){const s=e.join(e.dirname(i),".lck");t.existsSync(s)&&t.unlinkSync(s)}class n{constructor(s,n){this.cachePath=s,this.fileName=n,this.settings=[],this._listener=new i,this.file=e.join(this.cachePath,this.fileName),t.existsSync(this.cachePath)||t.mkdirSync(this.cachePath,{recursive:!0}),t.existsSync(this.file)||t.writeFileSync(this.file,""),this.cacheFileSettings(),this.watching=null,this.watch()}get listener(){return this._listener}parseContents(t){const e=t.split(/\r\n|\n|\r/),i=[];let s=null;for(const t of e){const e=t.trim();if(e.startsWith("[")&&e.endsWith("]")){s={name:e.slice(1,-1),settings:[]},i.push(s)}else if(e.startsWith(";")||e.startsWith("#"));else if(e&&s){const[t,i]=e.split("=");s.settings.push({key:t,value:i})}}if(e.length&&!s)return this.settings=[],void this.listener.emit("error",new Error("Invalid ini file format"));this.settings=i}async cacheFileSettings(){let e=0;await new Promise((i=>{for(;e<20;)try{const e=t.readFileSync(this.file,"utf8");return this.parseContents(e),void i(void 0)}catch(t){if(19===e)return void this.listener.emit("error",new Error(`Failed to read file after 20 attempts: ${t}`));e++,new Promise((t=>setTimeout(t,100)))}}))}getSetting(t,e,i=""){const s=this.settings.find((e=>e.name===t));if(!s)return i||null;const n=s.settings.find((t=>t.key===e));return n?n.value:i||null}setSetting(t,e,i){const s=this.settings.find((e=>e.name===t));if(!s)return void this.settings.push({name:t,settings:[{key:e,value:i}]});const n=s.settings.find((t=>t.key===e));n?n.value=i:s.settings.push({key:e,value:i})}getSections(){return this.settings.map((t=>t.name))}getKeys(t){const e=this.settings.find((e=>e.name===t));return e?e.settings.map((t=>t.key)):[]}hasSection(t){return this.settings.some((e=>e.name===t))}hasKey(t,e){const i=this.settings.find((e=>e.name===t));return!!i&&i.settings.some((t=>t.key===e))}removeSection(t){const e=this.settings.findIndex((e=>e.name===t));-1!==e&&this.settings.splice(e,1)}removeKey(t,e){const i=this.settings.find((e=>e.name===t));if(!i)return;const s=i.settings.findIndex((t=>t.key===e));-1!==s&&i.settings.splice(s,1)}async reload(){await this.cacheFileSettings(),this.listener.emit("reload",this.file)}async save(){let i="";for(const t of this.settings){i+=`[${t.name}]\n`;for(const e of t.settings)i+=`${e.key}=${e.value}\n`;i+="\n"}await async function(i){const s=e.join(e.dirname(i),".lck");let n=0;for(;t.existsSync(s)&&n<20;)await new Promise((t=>setTimeout(t,100))),n++;t.existsSync(s)||t.writeFileSync(s,"")}(this.file);try{t.writeFileSync(this.file,i,{flush:!0}),s(this.file),this.listener.emit("save",this.file)}catch(t){s(this.file),this.listener.emit("error",t)}}watch(){if(this.watching=t.watch(this.file,(async(t,e)=>{"change"===t&&(await this.cacheFileSettings(),this.listener.emit("change",e))})),this.watching)return this.watching.on("error",(t=>{this.listener.emit("error",t)})),void this.watching.once("close",(()=>{this.listener.emit("close")}));this.listener.emit("error",new Error("Failed to watch file"))}unwatch(){this.watching&&(t.unwatchFile(this.file),this.watching=null)}}export{n as default};
